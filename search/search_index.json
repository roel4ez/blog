{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Welcome to my blog! This is a collection of articles on a variety of topics, mostly technology, tools and hacks. {{ blog_content }}","title":"Home"},{"location":"#welcome","text":"Welcome to my blog! This is a collection of articles on a variety of topics, mostly technology, tools and hacks. {{ blog_content }}","title":"Welcome"},{"location":"tags/","text":"{{ tag_content }}","title":"Tags"},{"location":"articles/github-action-turn-on-off-vm/","text":"Background In one of the projects I'm involved in, there was the need to let a GitHub Action automatically turn on or off an Azure VM in the pipeline. The VM is required for running the full end-to-end test suite, but we don't want to have it running the whole time since it incurs a considerate costs if it is just idling away. Solution To enable this functionality, I created a reusable GitHub Action that can be integrated in any other pipeline: Power ON/OFF or DEALLOCATE a specific Azure VM It is very easy to use, just add step to any job in your Action: steps : - name : Power Azure VM uses : roel4ez/action-power-on-off-azure-vm@v1.0.1 with : AZURE_VM_NAME : <VM_NAME> AZURE_RG_NAME : <RESOURCE_GROUP_NAME> POWER_SWITCH : <ON/OFFDEALLOCATE> AZURE_SP_CLIENTID : ${{ secrets.AZURE_SP_CLIENTID }} AZURE_SP_SECRET : ${{ secrets.AZURE_SP_SECRET }} AZURE_TENANTID : ${{ secrets.AZURE_TENANTID }} For more info, refer to the README or have a look at the code yourself. Let me know what you think!","title":"Github Action for managing Azure VM"},{"location":"articles/github-action-turn-on-off-vm/#background","text":"In one of the projects I'm involved in, there was the need to let a GitHub Action automatically turn on or off an Azure VM in the pipeline. The VM is required for running the full end-to-end test suite, but we don't want to have it running the whole time since it incurs a considerate costs if it is just idling away.","title":"Background"},{"location":"articles/github-action-turn-on-off-vm/#solution","text":"To enable this functionality, I created a reusable GitHub Action that can be integrated in any other pipeline: Power ON/OFF or DEALLOCATE a specific Azure VM It is very easy to use, just add step to any job in your Action: steps : - name : Power Azure VM uses : roel4ez/action-power-on-off-azure-vm@v1.0.1 with : AZURE_VM_NAME : <VM_NAME> AZURE_RG_NAME : <RESOURCE_GROUP_NAME> POWER_SWITCH : <ON/OFFDEALLOCATE> AZURE_SP_CLIENTID : ${{ secrets.AZURE_SP_CLIENTID }} AZURE_SP_SECRET : ${{ secrets.AZURE_SP_SECRET }} AZURE_TENANTID : ${{ secrets.AZURE_TENANTID }} For more info, refer to the README or have a look at the code yourself. Let me know what you think!","title":"Solution"},{"location":"articles/mkdocs-mike-ghpages/","text":"Documentation. Developers either love it or hate it. Love it when it is available when they are trying to use the latest and greatest framework (guilty!), or hate it when they have to write it themselves. Luckily there are some really nice tools out there to manage the documentation for your projects. DocFX is one of them, this is the engine that is running the docs.microsoft.com sites. However, this article is about mkdocs . This is a neat little tool that can help you create a static site for your documentation. And it integrates nicely with GitHub Pages. Let's have a look at how to set up documentation with mkdocs and mkdocs-material. Later we'll have a look at using mike to manage versions. Requirements First of all you'll need Python on your machine, because this is what powers the whole thing. So go ahead and install that and also install pip while you are at it. Once you have this, you can install the prerequisites: - pip install mkdocs - pip install mkdocs-material - pip install mike There will be a couple of other extensions and plugins that you can use, and it probably makes sense to manage that in a requirements.txt file. Branching Let's say you have a main branch where all your code lives. You might be inclined to create a /docs folder there and start dumping your md files there. However, I recommend to keep your docs in a separate repository, so it can be maintained and managed individually (e.g. permissions). You do not need to setup a new GitHub repository for that, you can instead create a detached branch or orphan branch , called docs/main for example: git checkout docs/main --orphan If you want to have dev branch and docs branch side by side, try out git worktree git worktree git checkout docs/main # from the working folder: git worktree add c:/path-to-sources/repository.docs docs/main Get started For theming the documentation, I'm using mkdocs-material . They have a pretty good guide on how to get started , so I won't repeat all of that here. Instead, we'll skip to building and deploying Working locally For local development, use the docker-container provided by mkdocs-material . Run docker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material in the root directory of the docs to get a copy running on http://localhost:8000 . You can change the port in the docker run command if needed. Required extensions If you are using extensions which are not supported by the mkdocs-material container out-of-the-box, you have two ways to deal with this: use the manual approach Create a custom docker image with the plugin installed: Dockerfile FROM squidfunk/mkdocs-material RUN pip install mdx_truly_sane_lists # or copy your requirements.txt COPY requirements.txt . RUN pip install -r requirements.txt Build and run container # in the directory where your dockerfile is docker build . -t mkdocs-material-with-extensions docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs mkdocs-material-with-extensions Alternate approach Install Python and pip, and then the required packages: pip install -r requirements.txt mkdocs serve Configuration The file mkdocs.yml provides the main configuration for the website, such as color and themes, plugins and extension. The Table of Contents is also defined in the config file, under the section nav . This is where you can build the structure of your documentation page. Automate it! GitHub has two cool features we can leverage for our documentation: GitHub Actions: this let's us automate all the things GitHub Pages: a place to host a static site, hosted at http://<owner>.github.io/<repo> So let's do this: once you have something working locally, you can create a GitHub Action to do all the work for your. Luckily, mkdocs comes with a feature to help us out: mkdocs gh-deploy . This command will push to a branch called gh-pages , which is the default branch GitHub uses to host the files for the GitHub Pages (it's also an orphaned branch by the way). This means the action would look something like this: name: deploy on: push: branches: - docs/main # deploy on pushes to your documentation branch jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 with: fetch-depth: 0 - uses: actions/setup-python@v2 with: python-version: 3.x - run: pip install -r requirements.txt - run: mkdocs gh-deploy --force This is also the exact same action that powers the deployment of this blog! Versioning If you want to take things a bit further and provide versioning in your documentation, checkout the tool mike . This tool allows you to deploy multiple versions of your documentation. It sits nicely on top of mkdocs and integrates with everything that was discussed here. It also integrates nicely with GitHub Pages, which is very cool. Conclusion Besides what is mentioned here, there are of course also other tools that can achieve the same things, for example Jekyll . Choose what works for you. To see all of this in action, checkout the repository where I have set all of this up: iotedge-lorawan-starterkit . That is a very cool thing in itself, but a topic for another time! Feel free to take a look at the Actions we use there, and at the resulting documentation , including versioning.","title":"Awesome documentation with mkdocs and GitHub Pages"},{"location":"articles/mkdocs-mike-ghpages/#requirements","text":"First of all you'll need Python on your machine, because this is what powers the whole thing. So go ahead and install that and also install pip while you are at it. Once you have this, you can install the prerequisites: - pip install mkdocs - pip install mkdocs-material - pip install mike There will be a couple of other extensions and plugins that you can use, and it probably makes sense to manage that in a requirements.txt file.","title":"Requirements"},{"location":"articles/mkdocs-mike-ghpages/#branching","text":"Let's say you have a main branch where all your code lives. You might be inclined to create a /docs folder there and start dumping your md files there. However, I recommend to keep your docs in a separate repository, so it can be maintained and managed individually (e.g. permissions). You do not need to setup a new GitHub repository for that, you can instead create a detached branch or orphan branch , called docs/main for example: git checkout docs/main --orphan If you want to have dev branch and docs branch side by side, try out git worktree git worktree git checkout docs/main # from the working folder: git worktree add c:/path-to-sources/repository.docs docs/main","title":"Branching"},{"location":"articles/mkdocs-mike-ghpages/#get-started","text":"For theming the documentation, I'm using mkdocs-material . They have a pretty good guide on how to get started , so I won't repeat all of that here. Instead, we'll skip to building and deploying","title":"Get started"},{"location":"articles/mkdocs-mike-ghpages/#working-locally","text":"For local development, use the docker-container provided by mkdocs-material . Run docker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material in the root directory of the docs to get a copy running on http://localhost:8000 . You can change the port in the docker run command if needed. Required extensions If you are using extensions which are not supported by the mkdocs-material container out-of-the-box, you have two ways to deal with this: use the manual approach Create a custom docker image with the plugin installed: Dockerfile FROM squidfunk/mkdocs-material RUN pip install mdx_truly_sane_lists # or copy your requirements.txt COPY requirements.txt . RUN pip install -r requirements.txt Build and run container # in the directory where your dockerfile is docker build . -t mkdocs-material-with-extensions docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs mkdocs-material-with-extensions","title":"Working locally"},{"location":"articles/mkdocs-mike-ghpages/#alternate-approach","text":"Install Python and pip, and then the required packages: pip install -r requirements.txt mkdocs serve","title":"Alternate approach"},{"location":"articles/mkdocs-mike-ghpages/#configuration","text":"The file mkdocs.yml provides the main configuration for the website, such as color and themes, plugins and extension. The Table of Contents is also defined in the config file, under the section nav . This is where you can build the structure of your documentation page.","title":"Configuration"},{"location":"articles/mkdocs-mike-ghpages/#automate-it","text":"GitHub has two cool features we can leverage for our documentation: GitHub Actions: this let's us automate all the things GitHub Pages: a place to host a static site, hosted at http://<owner>.github.io/<repo> So let's do this: once you have something working locally, you can create a GitHub Action to do all the work for your. Luckily, mkdocs comes with a feature to help us out: mkdocs gh-deploy . This command will push to a branch called gh-pages , which is the default branch GitHub uses to host the files for the GitHub Pages (it's also an orphaned branch by the way). This means the action would look something like this: name: deploy on: push: branches: - docs/main # deploy on pushes to your documentation branch jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 with: fetch-depth: 0 - uses: actions/setup-python@v2 with: python-version: 3.x - run: pip install -r requirements.txt - run: mkdocs gh-deploy --force This is also the exact same action that powers the deployment of this blog!","title":"Automate it!"},{"location":"articles/mkdocs-mike-ghpages/#versioning","text":"If you want to take things a bit further and provide versioning in your documentation, checkout the tool mike . This tool allows you to deploy multiple versions of your documentation. It sits nicely on top of mkdocs and integrates with everything that was discussed here. It also integrates nicely with GitHub Pages, which is very cool.","title":"Versioning"},{"location":"articles/mkdocs-mike-ghpages/#conclusion","text":"Besides what is mentioned here, there are of course also other tools that can achieve the same things, for example Jekyll . Choose what works for you. To see all of this in action, checkout the repository where I have set all of this up: iotedge-lorawan-starterkit . That is a very cool thing in itself, but a topic for another time! Feel free to take a look at the Actions we use there, and at the resulting documentation , including versioning.","title":"Conclusion"},{"location":"articles/running-a-project-with-github-projects/","text":"The new GitHub Projects experience is in public beta for everyone to enjoy and use. You should be able to go ahead and createb a new project: Using it on a real project Currently, I'm working a with a CSE DevCrew on a public OSS project called IoTEdge LoRaWAN StarterKit . We were using \"classic\" GitHub projects in the past, but we've now moved to using the new beta experience. It's been a very great experience so far, and is slowly becoming a contender for AzureDevOps Boards or Jira. I'll list a few tips and tricks, as well as shortcomings and caveats, to learn how you could use this on your own projects. Creating a Product Backlog We created a Milestone to capture our Product Backlog (in our case, this is more an Engagement Backlog), which we called aptly January 2022 . I added all the items from this Milestone to the board, and got started with arranging the board to fit the daily needs of the team: a quick overview of what is in scope a board to manage the current sprint a board to triage new items during the daily Issue Hierarchy GitHub Issues have built-in support to track issues in other issues; in other words, it allows you to use some form of hierarchy in your items, the same as for example ADO or Jira would allow you to do. We choose to keep it simple and have 4 issue types: Epic , Feature , Story and Bug . A note on Sprints We use Milestones to manage our sprints, and create a milestone for each sprint (typically a week in length). There is also the possibility to create a custom field for \"Iteration\", but we decided not to use it. The milestones allow us to have a decent history of what issues we tackeld when, and there is a PowerBI report that uses it to report the progress (more on that in a next post? Let me know in the comments if you're interested). Different Views Different stackeholders of aproject require different views on your progress and status. That's why we ended up using these views: All Items : overview of all items in the Product Backlog - grouped by issue type \ud83e\udea7 Milestones : overview of issues per milestone \ud83c\udfc3 Current Sprint : Board of issues in the current sprint \ud83e\udeb2 Bugs : Board for triaging Bugs \ud83d\udfe3 Features : Board of Features for a high level overview \ud83d\udcd6 Stories : Board of Stories \u2757 No Milestone : Used for triaging new issues Most of them are pretty straight-forward, but I'll dive in to a few things here: Current Sprint During the daily, the scrum lead uses this board to show an overview on how we are doing in the current sprint. Remember, a sprint is a milestone in our case, so I used the filter functionality to show only stories and bugs for the current milestone: -type:feature milestone:<name-of-your-milestone> . More on the filter syntax can be found in the GitHub Docs Milestone names We tend to use extensive names for our milestones, and they usually have a nice emoji as well. If you do this, you'll need to include that specific emoji in the search field! For example: milestone:\"my great milestone \ud83d\ude48\" Configuration To make this board useful, I made sure all the relevant information is shown on each card, such as Linked Pull Request, Assignee and Labels No Milestone As mentioned before, this board is used for triaging new issues. AS part of the process, when someone creates an issue they will add it to the board, but not set a milestone. This results in the status being set to Triage and it will show up on this board. We then discuss each issue in the daily, and choose to assign it to either the Current Sprint, the Product Backlog or the VNext milestone. What is missing You might say \"\ud83e\udd14 this is great and all that, but I am missing feature X and Y and I will keep using Jira/AzureDevOps/Zendesk/..\" , and you may be right. There are definitely some things missing for a true project management solution, but it is more than good enough for running short projects. Nevertheless, here are a some things that I didn't like, or would love to see added in the future: Automatically add new issues to a board : currently this is only possible with external GitHub Apps. It would be great to be able to set this in the Issue Template Ability to add multiple issues at once : there is no way to add a bunch of issues to the board at once, either via a query or multi-select + action dropdown. (For example, this is possible for milestones, directly from the \"Issues\" view) Rules : I'd love to be able to set Rules for each column on the boards, for example: An items cannot be In Progress without having a milestone Limit number of items in a column Visualize Hierarchy : there is no way to visuaize the full hierarchy of an Epic for example. I'd love to be able to see all Features under an Epic, and all Stories under a Feature, in one glance. Conclusion Go ahead and play around with these new GitHub Boards, and let me know what you think!","title":"Running a project with github projects"},{"location":"articles/running-a-project-with-github-projects/#using-it-on-a-real-project","text":"Currently, I'm working a with a CSE DevCrew on a public OSS project called IoTEdge LoRaWAN StarterKit . We were using \"classic\" GitHub projects in the past, but we've now moved to using the new beta experience. It's been a very great experience so far, and is slowly becoming a contender for AzureDevOps Boards or Jira. I'll list a few tips and tricks, as well as shortcomings and caveats, to learn how you could use this on your own projects.","title":"Using it on a real project"},{"location":"articles/running-a-project-with-github-projects/#creating-a-product-backlog","text":"We created a Milestone to capture our Product Backlog (in our case, this is more an Engagement Backlog), which we called aptly January 2022 . I added all the items from this Milestone to the board, and got started with arranging the board to fit the daily needs of the team: a quick overview of what is in scope a board to manage the current sprint a board to triage new items during the daily","title":"Creating a Product Backlog"},{"location":"articles/running-a-project-with-github-projects/#issue-hierarchy","text":"GitHub Issues have built-in support to track issues in other issues; in other words, it allows you to use some form of hierarchy in your items, the same as for example ADO or Jira would allow you to do. We choose to keep it simple and have 4 issue types: Epic , Feature , Story and Bug . A note on Sprints We use Milestones to manage our sprints, and create a milestone for each sprint (typically a week in length). There is also the possibility to create a custom field for \"Iteration\", but we decided not to use it. The milestones allow us to have a decent history of what issues we tackeld when, and there is a PowerBI report that uses it to report the progress (more on that in a next post? Let me know in the comments if you're interested).","title":"Issue Hierarchy"},{"location":"articles/running-a-project-with-github-projects/#different-views","text":"Different stackeholders of aproject require different views on your progress and status. That's why we ended up using these views: All Items : overview of all items in the Product Backlog - grouped by issue type \ud83e\udea7 Milestones : overview of issues per milestone \ud83c\udfc3 Current Sprint : Board of issues in the current sprint \ud83e\udeb2 Bugs : Board for triaging Bugs \ud83d\udfe3 Features : Board of Features for a high level overview \ud83d\udcd6 Stories : Board of Stories \u2757 No Milestone : Used for triaging new issues Most of them are pretty straight-forward, but I'll dive in to a few things here:","title":"Different Views"},{"location":"articles/running-a-project-with-github-projects/#current-sprint","text":"During the daily, the scrum lead uses this board to show an overview on how we are doing in the current sprint. Remember, a sprint is a milestone in our case, so I used the filter functionality to show only stories and bugs for the current milestone: -type:feature milestone:<name-of-your-milestone> . More on the filter syntax can be found in the GitHub Docs Milestone names We tend to use extensive names for our milestones, and they usually have a nice emoji as well. If you do this, you'll need to include that specific emoji in the search field! For example: milestone:\"my great milestone \ud83d\ude48\"","title":"Current Sprint"},{"location":"articles/running-a-project-with-github-projects/#configuration","text":"To make this board useful, I made sure all the relevant information is shown on each card, such as Linked Pull Request, Assignee and Labels","title":"Configuration"},{"location":"articles/running-a-project-with-github-projects/#no-milestone","text":"As mentioned before, this board is used for triaging new issues. AS part of the process, when someone creates an issue they will add it to the board, but not set a milestone. This results in the status being set to Triage and it will show up on this board. We then discuss each issue in the daily, and choose to assign it to either the Current Sprint, the Product Backlog or the VNext milestone.","title":"No Milestone"},{"location":"articles/running-a-project-with-github-projects/#what-is-missing","text":"You might say \"\ud83e\udd14 this is great and all that, but I am missing feature X and Y and I will keep using Jira/AzureDevOps/Zendesk/..\" , and you may be right. There are definitely some things missing for a true project management solution, but it is more than good enough for running short projects. Nevertheless, here are a some things that I didn't like, or would love to see added in the future: Automatically add new issues to a board : currently this is only possible with external GitHub Apps. It would be great to be able to set this in the Issue Template Ability to add multiple issues at once : there is no way to add a bunch of issues to the board at once, either via a query or multi-select + action dropdown. (For example, this is possible for milestones, directly from the \"Issues\" view) Rules : I'd love to be able to set Rules for each column on the boards, for example: An items cannot be In Progress without having a milestone Limit number of items in a column Visualize Hierarchy : there is no way to visuaize the full hierarchy of an Epic for example. I'd love to be able to see all Features under an Epic, and all Stories under a Feature, in one glance.","title":"What is missing"},{"location":"articles/running-a-project-with-github-projects/#conclusion","text":"Go ahead and play around with these new GitHub Boards, and let me know what you think!","title":"Conclusion"}]}