{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Welcome to my blog! This is a collection of articles on a variety of topics, mostly technology, tools and hacks. {{ blog_content }}","title":"Home"},{"location":"#welcome","text":"Welcome to my blog! This is a collection of articles on a variety of topics, mostly technology, tools and hacks. {{ blog_content }}","title":"Welcome"},{"location":"tags/","text":"{{ tag_content }}","title":"Tags"},{"location":"articles/git-cherry-pick/","tags":["git","branching","pull-requests","cherry-pick"],"text":"This is the first in a series of articles on using the git CLI to be productive in your day-to-day work. Also, when you are really stuck with git, refer to https://ohshitgit.com for quick help! Creating a Pull Request One of the requests I've seen OSS repository owners make when reviewing PRs is that you use a small number of commits that fixes one specific issue . Generally, this is a good thing \u2122\ufe0f, as it makes it easier for the maintainer to review the PR and make sure it can be merged without issues. It also facilitates rolling back potential regressions that weren't caught by the tests for example. So what happens when the feedback on your PR is: LGTM, but it would be better to separate these changes into two PRs\". Great, now what? \ud83e\udd14 You've worked so long on this and now you have to do everything again? Cherries \ud83c\udf52 No worries, this is where git cherry-pick comes to the rescue. The official documentation describes it as \"Apply the changes introduced by some existing commits\" , but how do we use it in practice? Let's take the following situation for example, where the ask is to make two PRs: one that contains commit C1, and one that contains all commits starting from C2. How do we get from this: gitGraph commit branch feature/my-bugfix checkout feature/my-bugfix commit id: \"C1\" commit id: \"C2\" commit id: \"C3\" commit id: \"C4\" commit id: \"C5\" commit id: \"C6\" checkout main merge feature/my-bugfix to this? gitGraph commit branch feature/my-bugfix-1 checkout feature/my-bugfix-1 commit id: \"C1\" checkout main branch feature/my-bugfix-2 checkout feature/my-bugfix-2 commit id: \"C2\" commit id: \"C3\" commit id: \"C4\" commit id: \"C5\" commit id: \"C6\" checkout main merge feature/my-bugfix-1 merge feature/my-bugfix-2 Show me the code \ud83d\udcbb So do you have to do everything again? No , you can use git cherry-pick to setup your branches and create two new PRs. First, identify the hashes of the commits that are part of the first PR: Identify the commits that are part of the first PR $ [ feature/my-bugfix ] git log --all --decorate --oneline --graph # Show the commits in this feature branch, in a nicely formatted graph Git Commit Hashes git commit hashes are SHA-1 hashes that contain the commit message, the author, the date, a complete snapshot of files, as well as the parent commit hash. You can find them when looking at your git history with for example git log , or via the GitHub web interface. It is basically a pointer to where git can find the bit of code that is part of the commit. TIP The hash is actually a 40 character string, but git accepts the first 7 characters as a valid hash, which makes it easier to use. In the below example I'll just use C1, C2 and C3 as hashes. Once you know which commits are impacted and you have the hashes, you can start creating your new branches and PRs: Cherry-pick the commits to different branches $ [ feature/my-bugfix ] git checkout main $ [ main ] > git checkout -b feature/my-bugfix-1 # Create a new branch for the C1 changes git cherry-pick C1 # Cherry-pick only commit C1 git push --set-upstream origin fix/my-bugfix-1 # Push the branch to the remote git checkout main # Switch to main branch, since we want to use the same base branch for the other changes git checkout -b feature/my-bugfix-2 # Create a new branch for the C2 changes git cherry-pick C2..C6 # Cherry-pick commits C2 to C6 git push --set-upstream origin fix/my-bugfix-2 # Push the branch to the remote git push origin --delete feature/my-bugfix # delete the old branch remotely git branch -d feature/my-bugfix # delete the old branch locally Let's take it step by step. First, we are creating a new branch feature/my-bugfix-1 and cherry-picking the commit C1 into it. Then we do the same for feature/my-bugfix-2 , but instead of cherry-picking each commit, we can specify the range C2..C6 when executing the pick. Finally, we remove the old branch feature/my-bugfix , since we won't be needing that anymore. Now you can go ahead and create two new PRs with the new branches. Common pitfalls and caveats Cherry-picking copies commits, including the message and the timestamps, and applies the same changes to the target branch. This means git has created a new commit but leaves the old one around - be aware of this when looking at your git history. You can get yourself into trouble if you are not making small and self-contained changes. The bigger your commits, the more likely there will be conflicts. If the branch that you cherry-picked from is eventually merged into the target branch, you will end up with duplicate commits. cherry-pick does not work well when you don't have the remote branches, or when there are still unmerged changes on the target branch. git fetch might be able to fix some of these issues. Next steps Make sure to read the official documentation on cherry-picking, as there are a lot more caveats and pitfalls to be aware of. If you get into trouble, StackOverflow is a good place to look for help. Let me know on Twitter if you have any questions or remarks!","title":"Cherry-picking your commits for smaller Pull Requests"},{"location":"articles/git-cherry-pick/#creating-a-pull-request","text":"One of the requests I've seen OSS repository owners make when reviewing PRs is that you use a small number of commits that fixes one specific issue . Generally, this is a good thing \u2122\ufe0f, as it makes it easier for the maintainer to review the PR and make sure it can be merged without issues. It also facilitates rolling back potential regressions that weren't caught by the tests for example. So what happens when the feedback on your PR is: LGTM, but it would be better to separate these changes into two PRs\". Great, now what? \ud83e\udd14 You've worked so long on this and now you have to do everything again?","title":"Creating a Pull Request"},{"location":"articles/git-cherry-pick/#cherries","text":"No worries, this is where git cherry-pick comes to the rescue. The official documentation describes it as \"Apply the changes introduced by some existing commits\" , but how do we use it in practice? Let's take the following situation for example, where the ask is to make two PRs: one that contains commit C1, and one that contains all commits starting from C2. How do we get from this: gitGraph commit branch feature/my-bugfix checkout feature/my-bugfix commit id: \"C1\" commit id: \"C2\" commit id: \"C3\" commit id: \"C4\" commit id: \"C5\" commit id: \"C6\" checkout main merge feature/my-bugfix to this? gitGraph commit branch feature/my-bugfix-1 checkout feature/my-bugfix-1 commit id: \"C1\" checkout main branch feature/my-bugfix-2 checkout feature/my-bugfix-2 commit id: \"C2\" commit id: \"C3\" commit id: \"C4\" commit id: \"C5\" commit id: \"C6\" checkout main merge feature/my-bugfix-1 merge feature/my-bugfix-2","title":"Cherries \ud83c\udf52"},{"location":"articles/git-cherry-pick/#show-me-the-code","text":"So do you have to do everything again? No , you can use git cherry-pick to setup your branches and create two new PRs. First, identify the hashes of the commits that are part of the first PR: Identify the commits that are part of the first PR $ [ feature/my-bugfix ] git log --all --decorate --oneline --graph # Show the commits in this feature branch, in a nicely formatted graph Git Commit Hashes git commit hashes are SHA-1 hashes that contain the commit message, the author, the date, a complete snapshot of files, as well as the parent commit hash. You can find them when looking at your git history with for example git log , or via the GitHub web interface. It is basically a pointer to where git can find the bit of code that is part of the commit. TIP The hash is actually a 40 character string, but git accepts the first 7 characters as a valid hash, which makes it easier to use. In the below example I'll just use C1, C2 and C3 as hashes. Once you know which commits are impacted and you have the hashes, you can start creating your new branches and PRs: Cherry-pick the commits to different branches $ [ feature/my-bugfix ] git checkout main $ [ main ] > git checkout -b feature/my-bugfix-1 # Create a new branch for the C1 changes git cherry-pick C1 # Cherry-pick only commit C1 git push --set-upstream origin fix/my-bugfix-1 # Push the branch to the remote git checkout main # Switch to main branch, since we want to use the same base branch for the other changes git checkout -b feature/my-bugfix-2 # Create a new branch for the C2 changes git cherry-pick C2..C6 # Cherry-pick commits C2 to C6 git push --set-upstream origin fix/my-bugfix-2 # Push the branch to the remote git push origin --delete feature/my-bugfix # delete the old branch remotely git branch -d feature/my-bugfix # delete the old branch locally Let's take it step by step. First, we are creating a new branch feature/my-bugfix-1 and cherry-picking the commit C1 into it. Then we do the same for feature/my-bugfix-2 , but instead of cherry-picking each commit, we can specify the range C2..C6 when executing the pick. Finally, we remove the old branch feature/my-bugfix , since we won't be needing that anymore. Now you can go ahead and create two new PRs with the new branches.","title":"Show me the code \ud83d\udcbb"},{"location":"articles/git-cherry-pick/#common-pitfalls-and-caveats","text":"Cherry-picking copies commits, including the message and the timestamps, and applies the same changes to the target branch. This means git has created a new commit but leaves the old one around - be aware of this when looking at your git history. You can get yourself into trouble if you are not making small and self-contained changes. The bigger your commits, the more likely there will be conflicts. If the branch that you cherry-picked from is eventually merged into the target branch, you will end up with duplicate commits. cherry-pick does not work well when you don't have the remote branches, or when there are still unmerged changes on the target branch. git fetch might be able to fix some of these issues.","title":"Common pitfalls and caveats"},{"location":"articles/git-cherry-pick/#next-steps","text":"Make sure to read the official documentation on cherry-picking, as there are a lot more caveats and pitfalls to be aware of. If you get into trouble, StackOverflow is a good place to look for help. Let me know on Twitter if you have any questions or remarks!","title":"Next steps"},{"location":"articles/github-action-turn-on-off-vm/","tags":["github-action","azure"],"text":"Background In one of the projects I'm involved in, there was the need to let a GitHub Action automatically turn on or off an Azure VM in the pipeline. The VM is required for running the full end-to-end test suite, but we don't want to have it running the whole time since it incurs a considerate costs if it is just idling away. Solution To enable this functionality, I created a reusable GitHub Action that can be integrated in any other pipeline: Power ON/OFF or DEALLOCATE a specific Azure VM It is very easy to use, just add step to any job in your Action: steps : - name : Power Azure VM uses : roel4ez/action-power-on-off-azure-vm@v1.0.1 with : AZURE_VM_NAME : <VM_NAME> AZURE_RG_NAME : <RESOURCE_GROUP_NAME> POWER_SWITCH : <ON/OFFDEALLOCATE> AZURE_SP_CLIENTID : ${{ secrets.AZURE_SP_CLIENTID }} AZURE_SP_SECRET : ${{ secrets.AZURE_SP_SECRET }} AZURE_TENANTID : ${{ secrets.AZURE_TENANTID }} For more info, refer to the README or have a look at the code yourself. Let me know what you think!","title":"Github Action for managing Azure VM"},{"location":"articles/github-action-turn-on-off-vm/#background","text":"In one of the projects I'm involved in, there was the need to let a GitHub Action automatically turn on or off an Azure VM in the pipeline. The VM is required for running the full end-to-end test suite, but we don't want to have it running the whole time since it incurs a considerate costs if it is just idling away.","title":"Background"},{"location":"articles/github-action-turn-on-off-vm/#solution","text":"To enable this functionality, I created a reusable GitHub Action that can be integrated in any other pipeline: Power ON/OFF or DEALLOCATE a specific Azure VM It is very easy to use, just add step to any job in your Action: steps : - name : Power Azure VM uses : roel4ez/action-power-on-off-azure-vm@v1.0.1 with : AZURE_VM_NAME : <VM_NAME> AZURE_RG_NAME : <RESOURCE_GROUP_NAME> POWER_SWITCH : <ON/OFFDEALLOCATE> AZURE_SP_CLIENTID : ${{ secrets.AZURE_SP_CLIENTID }} AZURE_SP_SECRET : ${{ secrets.AZURE_SP_SECRET }} AZURE_TENANTID : ${{ secrets.AZURE_TENANTID }} For more info, refer to the README or have a look at the code yourself. Let me know what you think!","title":"Solution"},{"location":"articles/mkdocs-mike-ghpages/","tags":["blog","CI","mike"],"text":"Documentation. Developers either love it or hate it. Love it when it is available when they are trying to use the latest and greatest framework (guilty!), or hate it when they have to write it themselves. Luckily there are some really nice tools out there to manage the documentation for your projects. DocFX is one of them, this is the engine that is running the docs.microsoft.com sites. However, this article is about mkdocs . This is a neat little tool that can help you create a static site for your documentation. And it integrates nicely with GitHub Pages. Let's have a look at how to set up documentation with mkdocs and mkdocs-material. Later we'll have a look at using mike to manage versions. Requirements First of all you'll need Python on your machine, because this is what powers the whole thing. So go ahead and install that and also install pip while you are at it. Once you have this, you can install the prerequisites: - pip install mkdocs - pip install mkdocs-material - pip install mike There will be a couple of other extensions and plugins that you can use, and it probably makes sense to manage that in a requirements.txt file. Branching Let's say you have a main branch where all your code lives. You might be inclined to create a /docs folder there and start dumping your md files there. However, I recommend to keep your docs in a separate repository, so it can be maintained and managed individually (e.g. permissions). You do not need to setup a new GitHub repository for that, you can instead create a detached branch or orphan branch , called docs/main for example: git checkout docs/main --orphan If you want to have dev branch and docs branch side by side, try out git worktree git worktree git checkout docs/main # from the working folder: git worktree add c:/path-to-sources/repository.docs docs/main Get started For theming the documentation, I'm using mkdocs-material . They have a pretty good guide on how to get started , so I won't repeat all of that here. Instead, we'll skip to building and deploying Working locally For local development, use the docker-container provided by mkdocs-material . Run docker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material in the root directory of the docs to get a copy running on http://localhost:8000 . You can change the port in the docker run command if needed. Required extensions If you are using extensions which are not supported by the mkdocs-material container out-of-the-box, you have two ways to deal with this: use the manual approach Create a custom docker image with the plugin installed: Dockerfile FROM squidfunk/mkdocs-material RUN pip install mdx_truly_sane_lists # or copy your requirements.txt COPY requirements.txt . RUN pip install -r requirements.txt Build and run container # in the directory where your dockerfile is docker build . -t mkdocs-material-with-extensions docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs mkdocs-material-with-extensions Alternate approach Install Python and pip, and then the required packages: pip install -r requirements.txt mkdocs serve Configuration The file mkdocs.yml provides the main configuration for the website, such as color and themes, plugins and extension. The Table of Contents is also defined in the config file, under the section nav . This is where you can build the structure of your documentation page. Automate it! GitHub has two cool features we can leverage for our documentation: GitHub Actions: this let's us automate all the things GitHub Pages: a place to host a static site, hosted at http://<owner>.github.io/<repo> So let's do this: once you have something working locally, you can create a GitHub Action to do all the work for your. Luckily, mkdocs comes with a feature to help us out: mkdocs gh-deploy . This command will push to a branch called gh-pages , which is the default branch GitHub uses to host the files for the GitHub Pages (it's also an orphaned branch by the way). This means the action would look something like this: name: deploy on: push: branches: - docs/main # deploy on pushes to your documentation branch jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 with: fetch-depth: 0 - uses: actions/setup-python@v2 with: python-version: 3.x - run: pip install -r requirements.txt - run: mkdocs gh-deploy --force This is also the exact same action that powers the deployment of this blog! Versioning If you want to take things a bit further and provide versioning in your documentation, checkout the tool mike . This tool allows you to deploy multiple versions of your documentation. It sits nicely on top of mkdocs and integrates with everything that was discussed here. It also integrates nicely with GitHub Pages, which is very cool. Conclusion Besides what is mentioned here, there are of course also other tools that can achieve the same things, for example Jekyll . Choose what works for you. To see all of this in action, checkout the repository where I have set all of this up: iotedge-lorawan-starterkit . That is a very cool thing in itself, but a topic for another time! Feel free to take a look at the Actions we use there, and at the resulting documentation , including versioning.","title":"Awesome documentation with mkdocs and GitHub Pages"},{"location":"articles/mkdocs-mike-ghpages/#requirements","text":"First of all you'll need Python on your machine, because this is what powers the whole thing. So go ahead and install that and also install pip while you are at it. Once you have this, you can install the prerequisites: - pip install mkdocs - pip install mkdocs-material - pip install mike There will be a couple of other extensions and plugins that you can use, and it probably makes sense to manage that in a requirements.txt file.","title":"Requirements"},{"location":"articles/mkdocs-mike-ghpages/#branching","text":"Let's say you have a main branch where all your code lives. You might be inclined to create a /docs folder there and start dumping your md files there. However, I recommend to keep your docs in a separate repository, so it can be maintained and managed individually (e.g. permissions). You do not need to setup a new GitHub repository for that, you can instead create a detached branch or orphan branch , called docs/main for example: git checkout docs/main --orphan If you want to have dev branch and docs branch side by side, try out git worktree git worktree git checkout docs/main # from the working folder: git worktree add c:/path-to-sources/repository.docs docs/main","title":"Branching"},{"location":"articles/mkdocs-mike-ghpages/#get-started","text":"For theming the documentation, I'm using mkdocs-material . They have a pretty good guide on how to get started , so I won't repeat all of that here. Instead, we'll skip to building and deploying","title":"Get started"},{"location":"articles/mkdocs-mike-ghpages/#working-locally","text":"For local development, use the docker-container provided by mkdocs-material . Run docker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material in the root directory of the docs to get a copy running on http://localhost:8000 . You can change the port in the docker run command if needed. Required extensions If you are using extensions which are not supported by the mkdocs-material container out-of-the-box, you have two ways to deal with this: use the manual approach Create a custom docker image with the plugin installed: Dockerfile FROM squidfunk/mkdocs-material RUN pip install mdx_truly_sane_lists # or copy your requirements.txt COPY requirements.txt . RUN pip install -r requirements.txt Build and run container # in the directory where your dockerfile is docker build . -t mkdocs-material-with-extensions docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs mkdocs-material-with-extensions","title":"Working locally"},{"location":"articles/mkdocs-mike-ghpages/#alternate-approach","text":"Install Python and pip, and then the required packages: pip install -r requirements.txt mkdocs serve","title":"Alternate approach"},{"location":"articles/mkdocs-mike-ghpages/#configuration","text":"The file mkdocs.yml provides the main configuration for the website, such as color and themes, plugins and extension. The Table of Contents is also defined in the config file, under the section nav . This is where you can build the structure of your documentation page.","title":"Configuration"},{"location":"articles/mkdocs-mike-ghpages/#automate-it","text":"GitHub has two cool features we can leverage for our documentation: GitHub Actions: this let's us automate all the things GitHub Pages: a place to host a static site, hosted at http://<owner>.github.io/<repo> So let's do this: once you have something working locally, you can create a GitHub Action to do all the work for your. Luckily, mkdocs comes with a feature to help us out: mkdocs gh-deploy . This command will push to a branch called gh-pages , which is the default branch GitHub uses to host the files for the GitHub Pages (it's also an orphaned branch by the way). This means the action would look something like this: name: deploy on: push: branches: - docs/main # deploy on pushes to your documentation branch jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 with: fetch-depth: 0 - uses: actions/setup-python@v2 with: python-version: 3.x - run: pip install -r requirements.txt - run: mkdocs gh-deploy --force This is also the exact same action that powers the deployment of this blog!","title":"Automate it!"},{"location":"articles/mkdocs-mike-ghpages/#versioning","text":"If you want to take things a bit further and provide versioning in your documentation, checkout the tool mike . This tool allows you to deploy multiple versions of your documentation. It sits nicely on top of mkdocs and integrates with everything that was discussed here. It also integrates nicely with GitHub Pages, which is very cool.","title":"Versioning"},{"location":"articles/mkdocs-mike-ghpages/#conclusion","text":"Besides what is mentioned here, there are of course also other tools that can achieve the same things, for example Jekyll . Choose what works for you. To see all of this in action, checkout the repository where I have set all of this up: iotedge-lorawan-starterkit . That is a very cool thing in itself, but a topic for another time! Feel free to take a look at the Actions we use there, and at the resulting documentation , including versioning.","title":"Conclusion"},{"location":"articles/running-a-project-with-github-projects/","tags":["github","github-projects","project-management","agile"],"text":"The new GitHub Projects experience is in public beta for everyone to enjoy and use. You should be able to go ahead and create a new project: Using it on a real project Currently, I'm working a with a CSE DevCrew on a public OSS project called IoTEdge LoRaWAN StarterKit . We were using \"classic\" GitHub projects in the past, but we've now moved to using the new beta experience. It's been a very great experience so far, and it is quickly becoming a valid alternative for AzureDevOps Boards or Jira. I'll list a few tips and tricks, as well as shortcomings and caveats, to learn how you could use this on your own projects. Creating a Product Backlog We created a Milestone to capture our Product Backlog (in our case, this is more an Engagement Backlog), which we called aptly January 2022 . I added all the items from this Milestone to the board, and got started with arranging the board to fit the daily needs of the team: a quick overview of what is in scope a board to manage the current sprint a board to triage new items during the daily Issue Hierarchy GitHub Issues have built-in support to track issues in other issues; in other words, it allows you to use some form of hierarchy in your items, the same as for example ADO or Jira would allow you to do. We choose to keep it simple and have 4 issue types: Epic , Feature , Story and Bug . We use labels to mark the issues, and I've created a custom field on the board called Type to be able to group-by and filter the issues on that field. Note When adding an item, you can automatically set the Type if you add the issue in the correct group. A note on Sprints We use Milestones to manage our sprints, and create a milestone for each sprint (typically a week in length). There is also the possibility to create a custom field for \"Iteration\", but we decided not to use it. The milestones allow us to have a decent history of what issues we tackled when, and there is a PowerBI report that uses it to report the progress (more on that in a next post? Let me know in the comments if you're interested). Different Views Different stakeholders of a project require different views on progress and status. That's why we ended up using these views: All Items : overview of all items in the Product Backlog - grouped by issue type \ud83e\udea7 Milestones : overview of issues grouped by milestone \ud83c\udfc3 Current Sprint : Board of issues in the current sprint \ud83e\udeb2 Bugs : Board for triaging Bugs \ud83d\udfe3 Features : Board of Features for a high-level overview \ud83d\udcd6 Stories : Board of Stories \u2757 No Milestone : Used for triaging new issues Most of them are pretty straight-forward, but I'll dive into a few things here: Current Sprint During the daily, the scrum lead uses this board to show an overview on how we are doing in the current sprint. Remember, a sprint is a milestone in our case, so I used the filter functionality to show only stories and bugs for the current milestone: -type:feature milestone:<name-of-your-milestone> . More on the filter syntax can be found in the GitHub Docs Milestone names We tend to use extensive names for our milestones, and they usually have a nice emoji as well. If you do this, you'll need to include that specific emoji in the search field! For example: milestone:\"my great milestone \ud83d\ude48\" Configuration To make this board useful, I made sure all the relevant information is shown on each card, such as Linked Pull Request, Assignee and Labels No Milestone As mentioned before, this board is used for triaging new issues. As part of the process, when someone creates an issue they will add it to the board, but not set a milestone. This results in the status being set to Triage and it will show up on this board. We then discuss each issue in the daily standup, and choose to assign it to either the Current Sprint, the Product Backlog or the VNext milestone. What is missing You might say \"\ud83e\udd14 this is great and all that, but I am missing feature X and Y and I will keep using Jira/AzureDevOps/Zendesk/..\" , and you may be right. There are definitely some things missing for a true project management solution, but it is more than good enough for running short projects. Nevertheless, here are a some things that I didn't like, or would love to see added in the future: Automatically add new issues to a board : currently this is only possible with external GitHub Apps. It would be great to be able to set this in the Issue Template Ability to add multiple issues at once : there is no way to add a bunch of issues to the board at once, either via a query or multi-select + action dropdown. (For example, this is already possible for milestones, directly from the \"Issues\" view) Rules : I'd love to be able to set Rules for each column on the boards, for example: An item cannot be In Progress without having a milestone Limit number of items in a column Visualize Hierarchy : there is no way to visualize the full hierarchy of an Epic for example. I'd love to be able to see all Features under an Epic, and all Stories under a Feature, in one glance. Conclusion Go ahead and play around with these new GitHub Boards, and let me know what you think!","title":"Managing a project with the new GitHub Projects"},{"location":"articles/running-a-project-with-github-projects/#using-it-on-a-real-project","text":"Currently, I'm working a with a CSE DevCrew on a public OSS project called IoTEdge LoRaWAN StarterKit . We were using \"classic\" GitHub projects in the past, but we've now moved to using the new beta experience. It's been a very great experience so far, and it is quickly becoming a valid alternative for AzureDevOps Boards or Jira. I'll list a few tips and tricks, as well as shortcomings and caveats, to learn how you could use this on your own projects.","title":"Using it on a real project"},{"location":"articles/running-a-project-with-github-projects/#creating-a-product-backlog","text":"We created a Milestone to capture our Product Backlog (in our case, this is more an Engagement Backlog), which we called aptly January 2022 . I added all the items from this Milestone to the board, and got started with arranging the board to fit the daily needs of the team: a quick overview of what is in scope a board to manage the current sprint a board to triage new items during the daily","title":"Creating a Product Backlog"},{"location":"articles/running-a-project-with-github-projects/#issue-hierarchy","text":"GitHub Issues have built-in support to track issues in other issues; in other words, it allows you to use some form of hierarchy in your items, the same as for example ADO or Jira would allow you to do. We choose to keep it simple and have 4 issue types: Epic , Feature , Story and Bug . We use labels to mark the issues, and I've created a custom field on the board called Type to be able to group-by and filter the issues on that field. Note When adding an item, you can automatically set the Type if you add the issue in the correct group. A note on Sprints We use Milestones to manage our sprints, and create a milestone for each sprint (typically a week in length). There is also the possibility to create a custom field for \"Iteration\", but we decided not to use it. The milestones allow us to have a decent history of what issues we tackled when, and there is a PowerBI report that uses it to report the progress (more on that in a next post? Let me know in the comments if you're interested).","title":"Issue Hierarchy"},{"location":"articles/running-a-project-with-github-projects/#different-views","text":"Different stakeholders of a project require different views on progress and status. That's why we ended up using these views: All Items : overview of all items in the Product Backlog - grouped by issue type \ud83e\udea7 Milestones : overview of issues grouped by milestone \ud83c\udfc3 Current Sprint : Board of issues in the current sprint \ud83e\udeb2 Bugs : Board for triaging Bugs \ud83d\udfe3 Features : Board of Features for a high-level overview \ud83d\udcd6 Stories : Board of Stories \u2757 No Milestone : Used for triaging new issues Most of them are pretty straight-forward, but I'll dive into a few things here:","title":"Different Views"},{"location":"articles/running-a-project-with-github-projects/#current-sprint","text":"During the daily, the scrum lead uses this board to show an overview on how we are doing in the current sprint. Remember, a sprint is a milestone in our case, so I used the filter functionality to show only stories and bugs for the current milestone: -type:feature milestone:<name-of-your-milestone> . More on the filter syntax can be found in the GitHub Docs Milestone names We tend to use extensive names for our milestones, and they usually have a nice emoji as well. If you do this, you'll need to include that specific emoji in the search field! For example: milestone:\"my great milestone \ud83d\ude48\"","title":"Current Sprint"},{"location":"articles/running-a-project-with-github-projects/#configuration","text":"To make this board useful, I made sure all the relevant information is shown on each card, such as Linked Pull Request, Assignee and Labels","title":"Configuration"},{"location":"articles/running-a-project-with-github-projects/#no-milestone","text":"As mentioned before, this board is used for triaging new issues. As part of the process, when someone creates an issue they will add it to the board, but not set a milestone. This results in the status being set to Triage and it will show up on this board. We then discuss each issue in the daily standup, and choose to assign it to either the Current Sprint, the Product Backlog or the VNext milestone.","title":"No Milestone"},{"location":"articles/running-a-project-with-github-projects/#what-is-missing","text":"You might say \"\ud83e\udd14 this is great and all that, but I am missing feature X and Y and I will keep using Jira/AzureDevOps/Zendesk/..\" , and you may be right. There are definitely some things missing for a true project management solution, but it is more than good enough for running short projects. Nevertheless, here are a some things that I didn't like, or would love to see added in the future: Automatically add new issues to a board : currently this is only possible with external GitHub Apps. It would be great to be able to set this in the Issue Template Ability to add multiple issues at once : there is no way to add a bunch of issues to the board at once, either via a query or multi-select + action dropdown. (For example, this is already possible for milestones, directly from the \"Issues\" view) Rules : I'd love to be able to set Rules for each column on the boards, for example: An item cannot be In Progress without having a milestone Limit number of items in a column Visualize Hierarchy : there is no way to visualize the full hierarchy of an Epic for example. I'd love to be able to see all Features under an Epic, and all Stories under a Feature, in one glance.","title":"What is missing"},{"location":"articles/running-a-project-with-github-projects/#conclusion","text":"Go ahead and play around with these new GitHub Boards, and let me know what you think!","title":"Conclusion"}]}